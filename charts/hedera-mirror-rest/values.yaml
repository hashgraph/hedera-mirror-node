affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          topologyKey: kubernetes.io/hostname
          labelSelector:
            matchLabels:
              app.kubernetes.io/component: rest

annotations: {}

config:
  hedera:
    mirror:
      rest:
        metrics:
          config:
            authentication: false

# Environment variables to add to the container. The value can either be a string or an EnvVarSource. Evaluated as a template.
env:
  CONFIG_PATH: "/usr/etc/hedera/"
  # FOO:
  #   valueFrom:
  #     secretKeyRef:
  #       name: '{{ .Release.Name }}-custom'
  #       key: BAR

# Add config maps or secrets as environment variables. Evaluated as a template.
envFrom: []
# - secretRef:
#     name: '{{ .Release.Name }}-env'

fullnameOverride: ""

global:
  image: {}
  namespaceOverride: ""

hpa:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  utilization: 80

image:
  pullPolicy: IfNotPresent
  repository: gcr.io/mirrornode/hedera-mirror-rest
  tag: ""  # Defaults to the chart's app version

imagePullSecrets: []

ingress:
  annotations:
    traefik.ingress.kubernetes.io/router.middlewares: '{{ include "hedera-mirror-rest.namespace" . }}-{{ include "hedera-mirror-rest.fullname" . }}@kubernetescrd'
  enabled: true
  hosts:
    - host: ""
      paths: ["/api/v1"]
  middleware:
    circuitBreaker: NetworkErrorRatio() > 0.10 || ResponseCodeRatio(500, 600, 0, 600) > 0.25
    connectionsPerIP: 5
    enabled: false
    ipWhitelist:
      - 0.0.0.0/0
    rateLimit:
      average: 1000
      burst: 2000
  tls:
    enabled: false
    secretName: ""

inhibitRules:
  enabled: false
  InhibitRestAlertsWhenPodsDown:
    enabled: true
    matches:
      - sourceMatch:
          - name: alertname
            value: RestNoPodsReady
        targetMatch:
          - name: service
            value: rest

  InhibitRestAlertsWhenResourcesLow:
    enabled: true
    matches:
      - sourceMatch:
          - name: alertname
            value: RestHighCPU
        targetMatch:
          - name: service
            value: rest

  InhibitSlowResponseAlertsOnHighErrors:
    enabled: true
    matches:
      - sourceMatch:
          - name: alertname
            value: RestErrors
        targetMatch:
          - name: alertname
            value: rest

labels: {}

livenessProbe:
  httpGet:
    path: /health/liveness
    port: http
  initialDelaySeconds: 25
  timeoutSeconds: 2

nodeSelector: {}

podSecurityContext:
  fsGroup: 1000

priorityClassName: ""

prometheusRules:
  enabled: false
  RestErrors:
    annotations:
      description: "REST API 5xx error rate for {{ $labels.namespace }}/{{ $labels.pod }} is {{ $value | humanizePercentage }}"
      summary: "Mirror REST API error rate exceeds 5%"
    enabled: true
    expr: sum(rate(api_request_total{container="rest",code=~"^5.."}[5m])) by (namespace, pod) / sum(rate(api_request_total{container="rest"}[5m])) by (namespace, pod) > 0.05
    for: 1m
    labels:
      severity: critical
      service: rest

  RestHighCPU:
    annotations:
      description: "{{ $labels.namespace }}/{{ $labels.pod }} CPU usage reached {{ $value | humanizePercentage }}"
      summary: "Mirror REST API CPU usage exceeds 80%"
    enabled: true
    expr: sum(nodejs_process_cpu_usage_percentage{container="rest"}) by (namespace, pod) > 80
    for: 5m
    labels:
      severity: critical
      service: rest

  RestNoRequests:
    annotations:
      description: "REST API has not seen any requests to {{ $labels.namespace }}/{{ $labels.pod }} for 5m"
      summary: "No Mirror REST API requests seen for awhile"
    enabled: true
    expr: sum(rate(api_all_request_total{container="rest"}[3m])) by (namespace, pod) <= 0
    for: 5m
    labels:
      severity: warning
      service: rest

  RestSlowResponse:
    annotations:
      description: "{{ $labels.namespace }}/{{ $labels.pod }} is taking {{ $value | humanizeDuration }} to generate a response"
      summary: "Mirror REST API is taking too long to respond"
    enabled: true
    expr: sum(rate(api_request_duration_milliseconds_sum{container="rest"}[5m])) by (namespace, pod) / sum(rate(api_request_duration_milliseconds_count{container="rest"}[5m])) by (namespace, pod) > 2000
    for: 1m
    labels:
      severity: warning
      service: rest

  RestNoPodsReady:
    annotations:
      description: "No rest instances are currently running.  "
      summary: No rest instances running
    enabled: true
    expr: kube_pod_container_status_ready{container="rest"} < 1
    for: 30s
    labels:
      severity: critical
      service: rest

readinessProbe:
  httpGet:
    path: /health/readiness
    port: http
  initialDelaySeconds: 30
  timeoutSeconds: 2

# Only set if HPA is disabled
# replicas: 1

resources:
  limits:
    cpu: 500m
    memory: 128Mi
  requests:
    cpu: 20m
    memory: 32Mi

revisionHistoryLimit: 3

securityContext:
  capabilities:
    drop: [ALL]
  readOnlyRootFilesystem: true
  runAsGroup: 1000
  runAsNonRoot: true
  runAsUser: 1000

service:
  annotations: {}
  port: 80
  type: ClusterIP

serviceAccount:
  create: true
  # The name of the service account to use. If not set and create is true, a name is generated using the fullname template
  name:

serviceMonitor:
  enabled: false
  interval: 30s

terminationGracePeriodSeconds: 60

test:
  checkRecent: true
  enabled: true
  image:
    pullPolicy: IfNotPresent
    repository: bats/bats
    tag: 1.2.1

tolerations: []

updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 10%
    maxUnavailable: 25%

# Volumes to add to the container. The key is the volume name and the value is the volume mount definition. The same keys should also appear in volumes below.
volumeMounts:
  config:
    mountPath: /usr/etc/hedera

# Volume mounts to add to the container. The key is the volume name and the value is the volume definition. Evaluated as a template.
volumes:
  config:
    secret:
      defaultMode: 420
      secretName: '{{ include "hedera-mirror-rest.fullname" . }}'
