{{- $name := "mirror-passwords" -}}  # postgresl-ha doesn't support templated names
{{- $dbHost := include "hedera-mirror.db" . }}
{{- $dbHostPrimary := printf "%s-coord-primary" (include "hedera-mirror.stackgres" .) }}
{{- $dbName := .Values.db.name }}
{{- $dbSchema := .Values.db.schema }}
{{- $secret := lookup "v1" "Secret" (include "hedera-mirror.namespace" .) $name | default dict -}}
{{- $passwords := $secret.data | default dict -}}
{{- $graphqlPassword := coalesce .Values.graphql.db.password ($passwords.HEDERA_MIRROR_GRAPHQL_DB_PASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $graphqlUsername := .Values.graphql.db.username -}}
{{- $grpcPassword := coalesce .Values.grpc.db.password ($passwords.HEDERA_MIRROR_GRPC_DB_PASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $grpcUsername := .Values.grpc.db.username -}}
{{- $importerPassword := coalesce .Values.importer.db.password ($passwords.HEDERA_MIRROR_IMPORTER_DB_PASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $importerUsername := .Values.importer.db.username -}}
{{- $ownerPassword := coalesce .Values.db.owner.password ($passwords.HEDERA_MIRROR_IMPORTER_DB_OWNERPASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $ownerUsername := .Values.db.owner.username -}}
{{- $restPassword := coalesce .Values.rest.db.password ($passwords.HEDERA_MIRROR_IMPORTER_DB_RESTPASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $restUsername := .Values.rest.db.username -}}
{{- $rosettaPassword := coalesce .Values.rosetta.db.password ($passwords.HEDERA_MIRROR_ROSETTA_DB_PASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $rosettaUsername := .Values.rosetta.db.username -}}
{{- $web3Password := coalesce .Values.web3.db.password ($passwords.HEDERA_MIRROR_WEB3_DB_PASSWORD | default "" | b64dec) (randAlphaNum 40) -}}
{{- $web3Username := .Values.web3.db.username }}
apiVersion: v1
kind: Secret
metadata:
  labels: {{ include "hedera-mirror.labels" . | nindent 4 }}
  name: {{ $name }}
  namespace: {{ include "hedera-mirror.namespace" . }}
stringData:
  HEDERA_MIRROR_GRAPHQL_DB_HOST: "{{ $dbHost }}"
  HEDERA_MIRROR_GRAPHQL_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_GRAPHQL_DB_PASSWORD: "{{ $graphqlPassword }}"
  HEDERA_MIRROR_GRAPHQL_DB_USERNAME: "{{ $graphqlUsername }}"
  HEDERA_MIRROR_GRPC_DB_HOST: "{{ $dbHost }}"
  HEDERA_MIRROR_GRPC_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_GRPC_DB_PASSWORD: "{{ $grpcPassword }}"
  HEDERA_MIRROR_GRPC_DB_USERNAME: "{{ $grpcUsername }}"
  HEDERA_MIRROR_IMPORTER_DB_HOST: {{ ternary $dbHostPrimary $dbHost .Values.stackgres.enabled }}
  HEDERA_MIRROR_IMPORTER_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_IMPORTER_DB_SCHEMA: "{{ $dbSchema }}"
  HEDERA_MIRROR_IMPORTER_DB_PASSWORD: "{{ $importerPassword }}"
  HEDERA_MIRROR_IMPORTER_DB_USERNAME: "{{ $importerUsername }}"
  HEDERA_MIRROR_IMPORTER_DB_OWNERPASSWORD: "{{ $ownerPassword }}"
  HEDERA_MIRROR_IMPORTER_DB_OWNER: "{{ $ownerUsername }}"
  HEDERA_MIRROR_IMPORTER_DB_RESTPASSWORD: "{{ $restPassword }}"
  HEDERA_MIRROR_IMPORTER_DB_RESTUSERNAME: "{{ $restUsername }}"
  HEDERA_MIRROR_REST_DB_HOST: "{{ $dbHost }}"
  HEDERA_MIRROR_REST_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_REST_DB_PASSWORD: "{{ $restPassword }}"
  HEDERA_MIRROR_REST_DB_USERNAME: "{{ $restUsername }}"
  HEDERA_MIRROR_ROSETTA_DB_HOST: "{{ $dbHost }}"
  HEDERA_MIRROR_ROSETTA_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_ROSETTA_DB_PASSWORD: "{{ $rosettaPassword }}"
  HEDERA_MIRROR_ROSETTA_DB_USERNAME: "{{ $rosettaUsername }}"
  HEDERA_MIRROR_WEB3_DB_HOST: "{{ $dbHost }}"
  HEDERA_MIRROR_WEB3_DB_NAME: "{{ $dbName }}"
  HEDERA_MIRROR_WEB3_DB_PASSWORD: "{{ $web3Password }}"
  HEDERA_MIRROR_WEB3_DB_USERNAME: "{{ $web3Username }}"

  {{ if .Values.postgresql.enabled -}}
  admin-password: {{ coalesce .Values.postgresql.pgpool.adminPassword (get $passwords "admin-password" | default "" | b64dec) (randAlphaNum 40) | quote }}
  PGPOOL_POSTGRES_CUSTOM_PASSWORDS: "{{ $graphqlPassword }},{{ $grpcPassword }},{{ $importerPassword }},{{ $ownerPassword }},{{ $restPassword }},{{ $rosettaPassword }},{{ $web3Password }}"
  PGPOOL_POSTGRES_CUSTOM_USERS: "{{ $graphqlUsername }},{{ $grpcUsername }},{{ $importerUsername }},{{ $ownerUsername }},{{ $restUsername }},{{ $rosettaUsername }},{{ $web3Username }}"
  password: {{ coalesce .Values.postgresql.postgresql.password (get $passwords "password" | default "" | b64dec) (randAlphaNum 40) | quote }}
  repmgr-password: {{ coalesce .Values.postgresql.postgresql.repmgrPassword (get $passwords "repmgr-password" | default "" | b64dec) (randAlphaNum 40) | quote }}
  {{ end -}}

  {{- if .Values.stackgres.enabled }}
  all-postgres.sql: |
    create or replace function if_role_not_exists(rolename name, sql text) returns text as
    $$
    begin
      if not exists (select * from pg_roles where rolname = rolename) then
        execute sql;
        return format('Executed ''%s''', sql);
      else
        return format('role ''%s'' already exists', rolename);
      end if;
    end;
    $$
    language plpgsql;

    -- Create owner
    select if_role_not_exists('{{ $ownerUsername }}', 'create user {{ $ownerUsername }} with createrole login password ''{{ $ownerPassword }}''');
    alter database {{ $dbName }} set search_path = {{ $dbSchema }}, public;
    alter database {{ $dbName }} owner to {{ $ownerUsername }};

    -- Create roles
    select if_role_not_exists('readonly', 'create role readonly');
    select if_role_not_exists('readwrite', 'create role readwrite in role readonly');

    -- Create users
    select if_role_not_exists('{{ $graphqlUsername }}', 'create user {{ $graphqlUsername }} with login password ''{{ $graphqlPassword }}'' in role readonly');
    select if_role_not_exists('{{ $grpcUsername }}', 'create user {{ $grpcUsername }} with login password ''{{ $grpcPassword }}'' in role readonly');
    select if_role_not_exists('{{ $importerUsername }}', 'create user {{ $importerUsername }} with login password ''{{ $importerPassword }}'' in role readwrite');
    select if_role_not_exists('{{ $restUsername }}', 'create user {{ $restUsername }} with login password ''{{ $restPassword }}'' in role readonly');
    select if_role_not_exists('{{ $rosettaUsername }}', 'create user {{ $rosettaUsername }} with login password ''{{ $rosettaPassword }}'' in role readonly');
    select if_role_not_exists('{{ $web3Username }}', 'create user {{ $web3Username }} with login password ''{{ $web3Password }}'' in role readonly');
    drop function if_role_not_exists;

    -- Set statement timeouts
    alter user {{ $graphqlUsername }} set statement_timeout to '10000';
    alter user {{ $grpcUsername }} set statement_timeout to '10000';
    alter user {{ $restUsername }} set statement_timeout to '20000';
    alter user {{ $rosettaUsername }} set statement_timeout to '10000';
    alter user {{ $web3Username }} set statement_timeout to '10000';

  all-db.sql: |
    alter schema public owner to {{ $ownerUsername }};
    insert into pg_dist_authinfo(nodeid, rolename, authinfo) values
      (0, '{{ $graphqlUsername }}', 'password={{ $graphqlPassword }}'),
      (0, '{{ $grpcUsername }}', 'password={{ $grpcPassword }}'),
      (0, '{{ $importerUsername }}', 'password={{ $importerPassword }}'),
      (0, '{{ $ownerUsername }}', 'password={{ $ownerPassword }}'),
      (0, '{{ $restUsername }}', 'password={{ $restPassword }}'),
      (0, '{{ $rosettaUsername }}', 'password={{ $rosettaPassword }}'),
      (0, '{{ $web3Username }}', 'password={{ $web3Password }}')
    on conflict (nodeid, rolename)
    do update set authinfo = excluded.authinfo;

  coordinator-owner.sql: |
    -- Create schema
    create schema if not exists {{ $dbSchema }} authorization {{ $ownerUsername }};
    grant usage on schema {{ $dbSchema }} to public;
    revoke create on schema {{ $dbSchema }} from public;

    --  Grant readonly privileges
    grant connect on database {{ $dbName }} to readonly;
    grant select on all tables in schema {{ $dbSchema }} to readonly;
    grant usage on schema {{ $dbSchema }} to readonly;
    alter default privileges in schema {{ $dbSchema }} grant select on tables to readonly;

    -- Grant readwrite privileges
    grant insert, update, delete on all tables in schema {{ $dbSchema }} to readwrite;
    alter default privileges in schema {{ $dbSchema }} grant insert, update, delete on tables to readwrite;

  coordinator-superuser.sql: |
    -- Create extensions
    create extension if not exists btree_gist;
    create extension if not exists pg_cron;
    create extension if not exists pg_stat_statements;
    create schema if not exists partman authorization {{ $ownerUsername }};
    create extension if not exists pg_partman schema partman;
    alter schema partman owner to {{ $ownerUsername }};
    grant all on schema partman to {{ $ownerUsername }};
    grant usage on schema cron to {{ $ownerUsername }};
    grant all on all tables in schema partman to {{ $ownerUsername }};
    grant execute on all functions in schema partman to {{ $ownerUsername }};
    grant execute on all procedures in schema partman to {{ $ownerUsername }};
{{- end -}}
