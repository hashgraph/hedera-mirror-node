# Scalars
scalar Long
scalar Object

# Enums
enum EntityType {
    ACCOUNT
    CONTRACT
    FILE
    SCHEDULE
    TOKEN
    TOPIC
}

enum Order {
    ASC
    DESC
}

enum SidecarType {
    CONTRACT_ACTION
    CONTRACT_BYTECODE
    CONTRACT_STATE_CHANGE
}

enum TokenPauseStatus {
    UNPAUSED
    PAUSED
    NOT_APPLICABLE
}

enum TokenSupplyType {
    FINITE
    INFINITE
}

enum TokenType {
    NON_FUNGIBLE_UNIQUE
    FUNGIBLE_COMMON
}

enum TransactionType {
    CONSENSUSCREATETOPIC
    CONSENSUSDELETETOPIC
    CONSENSUSSUBMITMESSAGE
    CONSENSUSUPDATETOPIC
    CONTRACTCALL
    CONTRACTCREATEINSTANCE
    CONTRACTDELETEINSTANCE
    CONTRACTUPDATEINSTANCE
    CRYPTOADDLIVEHASH
    CRYPTOAPPROVEALLOWANCE
    CRYPTOCREATEACCOUNT
    CRYPTODELETE
    CRYPTODELETEALLOWANCE
    CRYPTODELETELIVEHASH
    CRYPTOTRANSFER
    CRYPTOUPDATEACCOUNT
    ETHEREUMTRANSACTION
    FILEAPPEND
    FILECREATE
    FILEDELETE
    FILEUPDATE
    FREEZE
    NODESTAKEUPDATE
    PRNG
    SCHEDULECREATE
    SCHEDULEDELETE
    SCHEDULESIGN
    SYSTEMDELETE
    SYSTEMUNDELETE
    TOKENASSOCIATE
    TOKENBURN
    TOKENCREATION
    TOKENDELETION
    TOKENDISSOCIATE
    TOKENFEESCHEDULEUPDATE
    TOKENFREEZE
    TOKENGRANTKYC
    TOKENMINT
    TOKENPAUSE
    TOKENREVOKEKYC
    TOKENUNFREEZE
    TOKENUNPAUSE
    TOKENUPDATE
    TOKENWIPE
    UNCHECKEDSUBMIT
    UNKNOWN
}

# Types
type EntityId {
    shard: Long!
    realm: Long!
    num: Long!
}

type Timestamp {
    seconds: Long!
    nanoseconds: Int!
}

type TimestampRange {
    from: Timestamp!
    to: Timestamp
}

type TransactionId {
    nonce: Int
    payerAccountId: EntityId
    scheduled: Boolean
    validStart: Timestamp
}

# Interfaces
interface Entity {
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!
}

interface Payer implements Entity {
    autoRenewAccount: Account
    autoRenewPeriod: Long
    balance: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    obtainer: Payer
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!
}

type Account implements Payer, Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    alias: String
    balance: Long
    declineReward: Boolean!
    evmAddress: [String]
    maxAutomaticTokenAssociations: Int
    nonce: Long
    obtainer: Payer
    pendingReward: Long
    receiverSigRequired: Boolean
    stakedAccountId: EntityId
    stakedNodeId: Long
    stakePeriodStart: Long
}

type Contract implements Payer, Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    balance: Long
    evmAddress: String
    file: File
    initcode: String
    nonce: Long
    obtainer: Payer
    results: [ContractResult!]!
    runtimeBytecode: String
    state(first: Int, after: String, order: Order = DESC): [ContractState!]!
}

type File implements Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    data(first: Int, after: String, order: Order = DESC): [FileData]!
}

type FileData {
    bytes: String
    consensusTimestamp: Timestamp!
    id: ID!
    transactionType: TransactionType!
}

type Schedule implements Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    creator: Payer!
    executedTimestamp: Timestamp
    payer: Payer!
    signatures: [TransactionSignature!]!
    transactionBody: String!
    waitForExpiry: Boolean!
}

type TransactionSignature {
    publicKeyPrefix: String!
    signature: String!
}

type Token implements Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    decimals: Long!
    customFees: [CustomFee!]!
    feeScheduleKey: Object
    freezeDefault: Boolean!
    freezeKey: Object
    initialSupply: Long!
    kycKey: Object
    maxSupply: Long!
    modifiedTimestamp: Timestamp!
    name: String!
    pauseKey: Object
    pauseStatus: TokenPauseStatus!
    supplyKey: Object
    supplyType: TokenSupplyType!
    symbol: String!
    totalSupply: Long!
    treasuryAccountId: EntityId!
    tokenType: TokenType!
    wipeKey: Object
}

type CustomFee {
    allCollectorsAreExempt: Boolean!
    amount: Long
    amountDenominator: Long
    collectorAccountId: EntityId
    createdTimestamp: Timestamp!
    denominatingTokenId: EntityId
    maximumAmount: Long
    minimumAmount: Long!
    netOfTransfers: Boolean
    royaltyDenominator: Long
    royaltyNumerator: Long
    tokenId: EntityId!
}

type Topic implements Entity {
    # Parent fields
    autoRenewAccount: Account
    autoRenewPeriod: Long
    createdTimestamp: Timestamp
    deleted: Boolean
    expirationTimestamp: Timestamp
    id: ID!
    key: Object
    memo: String!
    proxyAccount: Account
    timestampRange: TimestampRange!
    type: EntityType!

    # Child fields
    submitKey: Object
    messages(first: Int, after: String, order: Order = DESC): [TopicMessage!]!
}

type Node {
    description: String
    endpoints: [NodeEndpoint!]!
    maxStake: Long
    minStake: Long
    nodeAccountId: EntityId!
    nodeCertHash: String
    nodeId: EntityId!
    publicKey: String
    rewardRate: Long
    stake: Long
    stakeNotRewarded: Long
    stakeRewarded: Long
    stakingPeriod: TimestampRange
    timestamp: TimestampRange!
}

type NodeEndpoint {
    ipAddressV4: String!
    port: Int!
}

type ContractAction {
    callDepth: Int!
    callOperationType: Int!
    callType: Int!
    caller: EntityId!
    callerType: EntityType!
    consensusTimestamp: Timestamp!
    gas: Long!
    gasUsed: Long!
    index: Int!
    input: String
    recipientAccount: EntityId
    recipientAddress: String
    recipientContract: EntityId
    resultData: String
    resultDataType: Int!
    value: Long!
}

type ContractLog {
    bloom: String!
    consensusTimestamp: Timestamp!
    contractId: EntityId!
    data: String!
    index: Int!
    payerAccountId: EntityId!
    rootContractId: EntityId
    topic0: String
    topic1: String
    topic2: String
    topic3: String
}

type ContractResult {
    amount: Long
    bloom: String
    callResult: String
    consensusTimestamp: Timestamp!
    contractId: EntityId
    createdContractIds: [EntityId!]
    errorMessage: String
    failedInitcode: String
    functionParameters: String!
    functionResult: String
    gasLimit: Long!
    gasUsed: Long
    logs: [ContractLog!]!
    payerAccountId: EntityId!
    senderId: EntityId
    stateChanges: [ContractStateChange!]!
    transactionHash: String!
    transactionIndex: Int
    transactionResult: String!
}

type ContractState {
    contractId: EntityId!
    slot: String!
    timestamp: Timestamp!
    value: String
}

type ContractStateChange {
    consensusTimestamp: Timestamp!
    contractId: EntityId!
    migration: Boolean!
    payerAccountId: EntityId!
    slot: String!
    valueRead: String!
    valueWritten: String
}

type CryptoAllowance {
    amount: Long!
    owner: EntityId!
    payerAccountId: EntityId!
    spender: EntityId!
    timestampRange: TimestampRange!
}

type NetworkStake {
    consensusTimestamp: Timestamp!
    epochDay: Long!
    maxStakingRewardRatePerHbar: Long!
    nodeRewardFeeDenominator: Long!
    nodeRewardFeeNumerator: Long!
    stakeTotal: Long!
    stakingPeriod: Long!
    stakingPeriodDuration: Long!
    stakingPeriodsStored: Long!
    stakingRewardFeeDenominator: Long!
    stakingRewardFeeNumerator: Long!
    stakingRewardRate: Long!
    stakingStartThreshold: Long!
}

type Nft {
    accountId: EntityId
    createdTimestamp: Timestamp
    delegatingSpender: EntityId
    deleted: Boolean
    metadata: String
    modifiedTimestamp: Timestamp!
    serialNumber: Long!
    spender: EntityId
    tokenId: EntityId!
}

type NftAllowance {
    approvedForAll: Boolean!
    owner: EntityId!
    payerAccountId: EntityId!
    spender: EntityId!
    timestampRange: TimestampRange!
    tokenId: EntityId!
}

type Block {
    count: Long!
    gasUsed: Long
    hapiVersion: String
    hash: String!
    logsBloom: String
    name: String!
    number: Long!
    previousHash: String!
    sidecarCount: Int!
    size: Int
    timestamp: TimestampRange!
    version: Int!
}

type TokenAccount {
    accountId: EntityId!
    associated: Boolean!
    automaticAssociation: Boolean!
    balance: Long!
    createdTimestamp: Timestamp!
    freezeStatus: Int!
    kycStatus: Int!
    timestampRange: TimestampRange!
    tokenId: EntityId!
}

type TokenAllowance {
    amount: Long!
    owner: EntityId!
    payerAccountId: EntityId!
    spender: EntityId!
    timestampRange: TimestampRange!
    tokenId: EntityId!
}

type Prng {
    consensusTimestamp: Timestamp!
    prngBytes: String
    prngNumber: Int
    range: Int!
}

type TopicMessage {
    chunkNum: Int
    chunkTotal: Int
    consensusTimestamp: Timestamp!
    initialTransactionId: String
    message: String!
    payerAccountId: EntityId
    runningHash: String!
    runningHashVersion: Int!
    sequenceNumber: Long!
    topicId: EntityId!
    validStartTimestamp: Timestamp
}

type EthereumTransaction {
    accessList: String
    callData: String
    callDataId: EntityId
    chainId: String
    consensusTimestamp: Timestamp!
    data: String!
    gasLimit: Long!
    gasPrice: String
    hash: String!
    maxFeePerGas: String
    maxGasAllowance: Long!
    maxPriorityFeePerGas: String
    nonce: Long!
    payerAccountId: EntityId!
    recoveryId: Int
    signatureR: String!
    signatureS: String!
    signatureV: String
    toAddress: String
    type: Int!
    value: String
}

"""
Transaction contains the results of HAPI transactions on the network
"""
type Transaction {
    assessedCustomFees: [AssessedCustomFee!]!
    chargedFee: Long
    consensusTimestamp: Timestamp!
    entityId: EntityId
    hash: String
    id: ID!
    index: Int
    initialBalance: Long
    maxFee: Long
    memo: String
    nftTransfers: [NftTransfer!]!
    nodeAccountId: EntityId
    parentConsensusTimestamp: Timestamp
    result: String!
    stakingRewardTransfers: [StakingRewardTransfer!]!
    tokenTransfers: [TokenTransfer!]!
    transactionId: TransactionId!
    transfers: [Transfer!]!
    type: TransactionType!
    validDurationSeconds: Long
}

type AssessedCustomFee {
    amount: Long!
    collectorAccountId: EntityId!
    effectivePayerAccountIds: [EntityId!]!
    tokenId: EntityId
}

type NftTransfer {
    isApproval: Boolean
    receiverAccountId: EntityId
    senderAccountId: EntityId
    serialNumber: Long!
    tokenId: EntityId!
}

type StakingRewardTransfer {
    accountId: EntityId!
    amount: Int64!
}

type TokenTransfer {
    accountId: EntityId!
    amount: Long!
    isApproval: Boolean
    tokenId: EntityId!
}

type Transfer {
    amount: Long!
    entityId: EntityId!
    isApproval: Boolean
}

"""
The query root of Hedera's GraphQL interface.
"""
type Query {
    account(id: ID!): Account
    accounts: [Account!]!
    contract(id: ID!): Contract
    contracts: [Contract!]!
    entity(id: ID!): Entity
    file(id: ID!): File
    files: [File!]!
    node(id: ID!): Node
    nodes: [Node!]!
    schedule(id: ID!): Schedule
    schedules: [Schedule!]!
    token(id: ID!): Token
    tokens: [Token!]!
    topic(id: ID!): Topic
    topics: [Topic!]!
    transaction(id: ID!): Transaction
    transactions: [Transaction!]!
}
