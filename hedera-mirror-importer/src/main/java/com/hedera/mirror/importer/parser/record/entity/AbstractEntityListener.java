package com.hedera.mirror.importer.parser.record.entity;

/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import com.hedera.mirror.importer.domain.Entity;
import com.hedera.mirror.importer.domain.Nft;
import com.hedera.mirror.importer.domain.Schedule;
import com.hedera.mirror.importer.domain.Token;
import com.hedera.mirror.importer.domain.TokenAccount;

public class AbstractEntityListener implements EntityListener {

    protected Entity mergeEntity(Entity cachedEntity, Entity newEntity) {
        if (newEntity.getAutoRenewAccountId() != null) {
            cachedEntity.setAutoRenewAccountId(newEntity.getAutoRenewAccountId());
        }

        if (newEntity.getAutoRenewPeriod() != null) {
            cachedEntity.setAutoRenewPeriod(newEntity.getAutoRenewPeriod());
        }

        if (newEntity.getDeleted() != null) {
            cachedEntity.setDeleted(newEntity.getDeleted());
        }

        if (newEntity.getExpirationTimestamp() != null) {
            cachedEntity.setExpirationTimestamp(newEntity.getExpirationTimestamp());
        }

        if (newEntity.getKey() != null) {
            cachedEntity.setKey(newEntity.getKey());
            cachedEntity.setPublicKey(newEntity.getPublicKey());
        }

        if (newEntity.getMemo() != null) {
            cachedEntity.setMemo(newEntity.getMemo());
        }

        if (newEntity.getModifiedTimestamp() != null) {
            cachedEntity.setModifiedTimestamp(newEntity.getModifiedTimestamp());
        }

        if (newEntity.getProxyAccountId() != null) {
            cachedEntity.setProxyAccountId(newEntity.getProxyAccountId());
        }

        if (newEntity.getSubmitKey() != null) {
            cachedEntity.setSubmitKey(newEntity.getSubmitKey());
        }

        return cachedEntity;
    }

    protected Nft mergeNft(Nft cachedNft, Nft newNft) {
        if (cachedNft.getCreatedTimestamp() == null && newNft.getCreatedTimestamp() != null) {
            cachedNft.setCreatedTimestamp(newNft.getCreatedTimestamp());
        }

        if (newNft.getAccountId() != null) { // only domains generated by NftTransfers should set account
            cachedNft.setAccountId(newNft.getAccountId());
        }

        if (newNft.getDeleted() != null) {
            cachedNft.setDeleted(newNft.getDeleted());
        }

        if (newNft.getMetadata() != null) {
            cachedNft.setMetadata(newNft.getMetadata());
        }

        cachedNft.setModifiedTimestamp(newNft.getModifiedTimestamp());
        return cachedNft;
    }

    protected Schedule mergeSchedule(Schedule cachedSchedule, Schedule schedule) {
        cachedSchedule.setExecutedTimestamp(schedule.getExecutedTimestamp());
        return cachedSchedule;
    }

    protected Token mergeToken(Token cachedToken, Token newToken) {
        if (newToken.getFreezeKey() != null) {
            cachedToken.setFreezeKey(newToken.getFreezeKey());
        }

        if (newToken.getKycKey() != null) {
            cachedToken.setKycKey(newToken.getKycKey());
        }

        if (newToken.getName() != null) {
            cachedToken.setName(newToken.getName());
        }

        if (newToken.getPauseKey() != null) {
            cachedToken.setPauseKey(newToken.getPauseKey());
        }

        if (newToken.getPauseStatus() != null) {
            cachedToken.setPauseStatus(newToken.getPauseStatus());
        }

        if (newToken.getSupplyKey() != null) {
            cachedToken.setSupplyKey(newToken.getSupplyKey());
        }

        if (newToken.getSymbol() != null) {
            cachedToken.setSymbol(newToken.getSymbol());
        }

        if (newToken.getTotalSupply() != null) {
            Long newTotalSupply = newToken.getTotalSupply();
            if (cachedToken.getTotalSupply() != null && newTotalSupply < 0) {
                // if the cached token has total supply set, and the new total supply is negative because it's an update
                // from the token transfer of a token dissociate of a deleted token, aggregate the change
                cachedToken.setTotalSupply(cachedToken.getTotalSupply() + newTotalSupply);
            } else {
                // if the cached token doesn't have total supply or the new total supply is non-negative, set it to the
                // new token's total supply. Later step should apply the change on the current total supply in db if
                // the value is negative.
                cachedToken.setTotalSupply(newToken.getTotalSupply());
            }
        }

        if (newToken.getTreasuryAccountId() != null) {
            cachedToken.setTreasuryAccountId(newToken.getTreasuryAccountId());
        }

        if (newToken.getWipeKey() != null) {
            cachedToken.setWipeKey(newToken.getWipeKey());
        }

        cachedToken.setModifiedTimestamp(newToken.getModifiedTimestamp());
        return cachedToken;
    }

    protected TokenAccount mergeTokenAccount(TokenAccount lastTokenAccount, TokenAccount newTokenAccount) {
        if (newTokenAccount.getCreatedTimestamp() != null) {
            return newTokenAccount;
        }

        // newTokenAccount is a partial update. It must have its id (tokenId, accountId, modifiedTimestamp) set.
        // copy the lifespan immutable fields createdTimestamp and automaticAssociation from the last snapshot.
        // copy other fields from the last snapshot if not set in newTokenAccount
        newTokenAccount.setCreatedTimestamp(lastTokenAccount.getCreatedTimestamp());
        newTokenAccount.setAutomaticAssociation(lastTokenAccount.getAutomaticAssociation());

        if (newTokenAccount.getAssociated() == null) {
            newTokenAccount.setAssociated(lastTokenAccount.getAssociated());
        }

        if (newTokenAccount.getFreezeStatus() == null) {
            newTokenAccount.setFreezeStatus(lastTokenAccount.getFreezeStatus());
        }

        if (newTokenAccount.getKycStatus() == null) {
            newTokenAccount.setKycStatus(lastTokenAccount.getKycStatus());
        }

        return newTokenAccount;
    }
}
