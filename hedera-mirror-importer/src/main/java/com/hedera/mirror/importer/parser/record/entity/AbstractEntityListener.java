package com.hedera.mirror.importer.parser.record.entity;

/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import com.hedera.mirror.importer.domain.Entity;
import com.hedera.mirror.importer.domain.EntityId;
import com.hedera.mirror.importer.domain.Nft;
import com.hedera.mirror.importer.domain.Schedule;
import com.hedera.mirror.importer.domain.Token;
import com.hedera.mirror.importer.domain.TokenAccount;

public class AbstractEntityListener implements EntityListener {

    protected Entity mergeEntity(Entity cachedEntity, Entity newEntity) {
        if (newEntity.getAutoRenewAccountId() != null) {
            cachedEntity.setAutoRenewAccountId(newEntity.getAutoRenewAccountId());
        }

        if (newEntity.getAutoRenewPeriod() != null) {
            cachedEntity.setAutoRenewPeriod(newEntity.getAutoRenewPeriod());
        }

        if (newEntity.getDeleted() != null) {
            cachedEntity.setDeleted(newEntity.getDeleted());
        }

        if (newEntity.getExpirationTimestamp() != null) {
            cachedEntity.setExpirationTimestamp(newEntity.getExpirationTimestamp());
        }

        if (newEntity.getKey() != null) {
            cachedEntity.setKey(newEntity.getKey());
            cachedEntity.setPublicKey(newEntity.getPublicKey());
        }

        if (newEntity.getMemo() != null) {
            cachedEntity.setMemo(newEntity.getMemo());
        }

        if (newEntity.getModifiedTimestamp() != null) {
            cachedEntity.setModifiedTimestamp(newEntity.getModifiedTimestamp());
        }

        if (newEntity.getProxyAccountId() != null) {
            cachedEntity.setProxyAccountId(newEntity.getProxyAccountId());
        }

        if (newEntity.getSubmitKey() != null) {
            cachedEntity.setSubmitKey(newEntity.getSubmitKey());
        }

        return cachedEntity;
    }

    protected Nft mergeNft(Nft cachedNft, Nft newNft) {
        if (cachedNft.getCreatedTimestamp() == null && newNft.getCreatedTimestamp() != null) {
            cachedNft.setCreatedTimestamp(newNft.getCreatedTimestamp());
        }

        if (newNft.getMetadata() == null) { // only domains generated by NftTransfers should set account
            cachedNft.setAccountId(newNft.getAccountId() == null ? EntityId.EMPTY : newNft.getAccountId());
        }

        if (newNft.getDeleted() != null) {
            cachedNft.setDeleted(newNft.getDeleted());
        }

        if (newNft.getMetadata() != null) {
            cachedNft.setMetadata(newNft.getMetadata());
        }

        cachedNft.setModifiedTimestamp(newNft.getModifiedTimestamp());
        return cachedNft;
    }

    protected Schedule mergeSchedule(Schedule cachedSchedule, Schedule schedule) {
        cachedSchedule.setExecutedTimestamp(schedule.getExecutedTimestamp());
        return cachedSchedule;
    }

    protected Token mergeToken(Token cachedToken, Token newToken) {
        if (newToken.getFreezeKey() != null) {
            cachedToken.setFreezeKey(newToken.getFreezeKey());
        }

        if (newToken.getKycKey() != null) {
            cachedToken.setKycKey(newToken.getKycKey());
        }

        if (newToken.getName() != null) {
            cachedToken.setName(newToken.getName());
        }

        if (newToken.getSupplyKey() != null) {
            cachedToken.setSupplyKey(newToken.getSupplyKey());
        }

        if (newToken.getSymbol() != null) {
            cachedToken.setSymbol(newToken.getSymbol());
        }

        if (newToken.getTotalSupply() != null) {
            cachedToken.setTotalSupply(newToken.getTotalSupply());
        }

        if (newToken.getTreasuryAccountId() != null) {
            cachedToken.setTreasuryAccountId(newToken.getTreasuryAccountId());
        }

        if (newToken.getWipeKey() != null) {
            cachedToken.setWipeKey(newToken.getWipeKey());
        }

        cachedToken.setModifiedTimestamp(newToken.getModifiedTimestamp());
        return cachedToken;
    }

    protected TokenAccount mergeTokenAccount(TokenAccount lastTokenAccount, TokenAccount newTokenAccount) {
        // newTokenAccount must have its id (tokenId, accountId, modifiedTimestamp) set
        // copy the lifespan immutable fields createdTimestamp and automaticAssociation from the last snapshot
        // copy other fields from the last snapshot if not set in newTokenAccount
        newTokenAccount.setCreatedTimestamp(lastTokenAccount.getCreatedTimestamp());
        newTokenAccount.setAutomaticAssociation(lastTokenAccount.getAutomaticAssociation());

        if (newTokenAccount.getAssociated() == null) {
            newTokenAccount.setAssociated(lastTokenAccount.getAssociated());
        }

        if (newTokenAccount.getFreezeStatus() == null) {
            newTokenAccount.setFreezeStatus(lastTokenAccount.getFreezeStatus());
        }

        if (newTokenAccount.getKycStatus() == null) {
            newTokenAccount.setKycStatus(lastTokenAccount.getKycStatus());
        }

        return newTokenAccount;
    }
}
