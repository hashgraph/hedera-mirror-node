/*
 * Copyright (C) 2023 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hedera.services.store.contracts.precompile;

import static com.hedera.mirror.web3.common.PrecompileContext.PRECOMPILE_CONTEXT;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.TEST_CONSENSUS_TIME;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.account;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.contractAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.recipientAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.sender;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.senderAddress;
import static com.hedera.services.store.contracts.precompile.HTSTestsUtil.timestamp;
import static com.hedera.services.store.contracts.precompile.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_CURRENTLY_CREATED_TOKEN;
import static com.hedera.services.store.contracts.precompile.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_EXISTING_FUNGIBLE_TOKEN;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreate;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateV3;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateWithFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateWithFeesV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeFungibleCreateWithFeesV3;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreate;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateV3;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateWithFees;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateWithFeesV2;
import static com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile.decodeNonFungibleCreateWithFeesV3;
import static com.hederahashgraph.api.proto.java.HederaFunctionality.TokenCreate;
import static java.util.function.UnaryOperator.identity;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

import com.hedera.mirror.web3.common.PrecompileContext;
import com.hedera.mirror.web3.evm.properties.MirrorNodeEvmProperties;
import com.hedera.mirror.web3.evm.store.Store;
import com.hedera.mirror.web3.evm.store.Store.OnMissing;
import com.hedera.mirror.web3.evm.store.contract.HederaEvmStackedWorldStateUpdater;
import com.hedera.node.app.service.evm.accounts.HederaEvmContractAliases;
import com.hedera.node.app.service.evm.store.contracts.precompile.EvmHTSPrecompiledContract;
import com.hedera.node.app.service.evm.store.contracts.precompile.EvmInfrastructureFactory;
import com.hedera.node.app.service.evm.store.tokens.TokenAccessor;
import com.hedera.services.fees.FeeCalculator;
import com.hedera.services.fees.HbarCentExchange;
import com.hedera.services.fees.calculation.UsagePricesProvider;
import com.hedera.services.fees.pricing.AssetsLoader;
import com.hedera.services.hapi.utils.fees.FeeObject;
import com.hedera.services.jproto.JECDSASecp256k1Key;
import com.hedera.services.jproto.JEd25519Key;
import com.hedera.services.store.contracts.precompile.codec.EncodingFacade;
import com.hedera.services.store.contracts.precompile.codec.KeyValueWrapper;
import com.hedera.services.store.contracts.precompile.codec.TokenCreateResult;
import com.hedera.services.store.contracts.precompile.codec.TokenKeyWrapper;
import com.hedera.services.store.contracts.precompile.impl.TokenCreatePrecompile;
import com.hedera.services.store.contracts.precompile.utils.PrecompilePricingUtils;
import com.hedera.services.store.models.Id;
import com.hedera.services.txn.token.CreateLogic;
import com.hedera.services.txns.validation.OptionValidator;
import com.hedera.services.utils.EntityIdUtils;
import com.hedera.services.utils.accessors.AccessorFactory;
import com.hederahashgraph.api.proto.java.AccountID;
import com.hederahashgraph.api.proto.java.ContractID;
import com.hederahashgraph.api.proto.java.HederaFunctionality;
import com.hederahashgraph.api.proto.java.ResponseCodeEnum;
import com.hederahashgraph.api.proto.java.SubType;
import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;
import com.hederahashgraph.api.proto.java.TokenID;
import com.hederahashgraph.api.proto.java.TransactionBody;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Deque;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.UnaryOperator;
import org.apache.tuweni.bytes.Bytes;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.evm.account.Account;
import org.hyperledger.besu.evm.frame.BlockValues;
import org.hyperledger.besu.evm.frame.ExceptionalHaltReason;
import org.hyperledger.besu.evm.frame.MessageFrame;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TokenCreatePrecompileTest {
    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT = Bytes.fromHexString(
            "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT = Bytes.fromHexString(
            "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003");
    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT = Bytes.fromHexString(
            "0x9dc711e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT = Bytes.fromHexString(
            "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003f1000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS = Bytes.fromHexString(
            "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE = Bytes.fromHexString(
            "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT =
            Bytes.fromHexString(
                    "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000008000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT_V2 = Bytes.fromHexString(
            "c23baeb600000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000007fffffffffffffff0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT_V3 = Bytes.fromHexString(
            "0x0fb65bf300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000007fffffffffffffff0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_V2 = Bytes.fromHexString(
            "0xb937581a00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001");
    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_V3 = Bytes.fromHexString(
            "0x2af0c59a00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000094d79546f6b656e5632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d544b563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001");
    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2 = Bytes.fromHexString(
            "0x9c89bb350000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V3 = Bytes.fromHexString(
            "0xea83f2930000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2 = Bytes.fromHexString(
            "0x457339690000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002");
    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V3 = Bytes.fromHexString(
            "0xabb54eb50000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000007fffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d794e465456320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4654563200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096e66744d656d6f56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002");
    private static final long TEST_SERVICE_FEE = 100L;
    private static final long TEST_NODE_FEE = 100_000L;
    private static final long TEST_NETWORK_FEE = 100L;
    private static final long EXPECTED_TINYBARS_REQUIREMENT = (TEST_SERVICE_FEE + TEST_NETWORK_FEE + TEST_NODE_FEE)
            + (TEST_SERVICE_FEE + TEST_NETWORK_FEE + TEST_NODE_FEE) / 5;
    private static final long SENDER_INITIAL_BALANCE = 1_000_000L;

    @Mock
    private AssetsLoader assetLoader;

    @Mock
    private HbarCentExchange exchange;

    @Mock
    private FeeCalculator feeCalculator;

    @Mock
    private AccessorFactory accessorFactory;

    @Mock
    private UsagePricesProvider resourceCosts;

    @Mock
    private EncodingFacade encoder;

    @Mock
    private CreateLogic createLogic;

    private TransactionBody.Builder transactionBody =
            TransactionBody.newBuilder().setTokenCreation(TokenCreateTransactionBody.newBuilder());

    @Mock
    private MessageFrame frame;

    @Mock
    private HederaEvmStackedWorldStateUpdater worldUpdater;

    @Mock
    private Store store;

    @Mock
    private EvmInfrastructureFactory infrastructureFactory;

    @Mock
    private OptionValidator validator;

    @InjectMocks
    private MirrorNodeEvmProperties evmProperties;

    @Mock
    private EvmHTSPrecompiledContract evmHTSPrecompiledContract;

    @Mock
    private Account account;

    @Mock
    com.hedera.services.store.models.Account senderAccount;

    @Mock
    private Deque<MessageFrame> stack;

    @Mock
    private Iterator<MessageFrame> dequeIterator;

    @Mock
    private MessageFrame lastFrame;

    @Mock
    private HederaEvmContractAliases hederaEvmContractAliases;

    @Mock
    private TokenAccessor tokenAccessor;

    @Mock
    private PrecompileContext precompileContext;

    private TokenCreatePrecompile tokenCreatePrecompile;
    private MockedStatic<TokenCreatePrecompile> staticTokenCreatePrecompile;

    private HTSPrecompiledContract subject;
    protected static final byte[] ED25519_KEY = new byte[] {
        -44, -10, 81, 99, 100, 6, -8, -94, -87, -112, 42, 42, 96, 75, -31, -5, 72, 13, -70, 101, -111, -1, 77, -103, 47,
        -118, 107, -58, -85, -63, 55, -57
    };

    @BeforeEach
    void setUp() throws IOException {
        final Map<HederaFunctionality, Map<SubType, BigDecimal>> canonicalPrices = new HashMap<>();
        canonicalPrices.put(TokenCreate, Map.of(SubType.DEFAULT, BigDecimal.valueOf(0)));
        given(assetLoader.loadCanonicalPrices()).willReturn(canonicalPrices);

        final PrecompilePricingUtils precompilePricingUtils =
                new PrecompilePricingUtils(assetLoader, exchange, feeCalculator, resourceCosts, accessorFactory);
        final var syntheticTxnFactory = new SyntheticTxnFactory();
        tokenCreatePrecompile = new TokenCreatePrecompile(
                precompilePricingUtils, encoder, syntheticTxnFactory, validator, createLogic, feeCalculator);
        final var precompileMapper = new PrecompileMapper(Set.of(tokenCreatePrecompile));

        subject = new HTSPrecompiledContract(
                infrastructureFactory,
                evmProperties,
                precompileMapper,
                evmHTSPrecompiledContract,
                store,
                tokenAccessor,
                precompilePricingUtils);
    }

    @AfterEach
    void cleanUp() {
        if (staticTokenCreatePrecompile != null) {
            staticTokenCreatePrecompile.close();
        }
    }

    @Test
    void testMinimumFeeInTinyBars() {
        final var expectedFee = 100_000L;
        final var minimumFee =
                tokenCreatePrecompile.getMinimumFeeInTinybars(HTSTestsUtil.timestamp, transactionBody.build(), sender);
        assertEquals(expectedFee, minimumFee);
    }

    @Test
    void verifyGetSuccessResultFor() {
        final var expected = encoder.encodeCreateSuccess(HTSTestsUtil.tokenAddress);
        final var result = tokenCreatePrecompile.getSuccessResultFor(new TokenCreateResult(HTSTestsUtil.token));
        assertEquals(expected, result);
    }

    @Test
    void verifyGetFailureResultFor() {
        final var expected = encoder.encodeCreateFailure(ResponseCodeEnum.FAIL_INVALID);
        final var result = tokenCreatePrecompile.getFailureResultFor(ResponseCodeEnum.FAIL_INVALID);
        assertEquals(expected, result);
    }

    @Test
    void decodeFungibleCreateNoFeesInput() {
        final var decodedInput = decodeFungibleCreate(CREATE_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(200), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(8), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeFungibleCreateWithFeesInput() {
        final var decodedInput = decodeFungibleCreateWithFees(CREATE_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(200));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(8));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_CURRENTLY_CREATED_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder()
                        .setTokenNum(0)
                        .setRealmNum(0)
                        .setShardNum(0)
                        .build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(5, fractionalFeeWrapper.numerator());
        assertEquals(6, fractionalFeeWrapper.denominator());
        assertEquals(55, fractionalFeeWrapper.minimumAmount());
        assertEquals(100, fractionalFeeWrapper.maximumAmount());
        assertTrue(fractionalFeeWrapper.netOfTransfers());
        assertEquals(AccountID.newBuilder().setAccountNum(3).build(), fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateNoFeesInput() {
        final var decodedInput = decodeNonFungibleCreate(CREATE_NON_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());
    }

    @Test
    void decodeNonFungibleCreateWithFeesInput() {
        final var decodedInput = decodeNonFungibleCreateWithFees(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1009).build(), customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(2, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(4, royaltyFeeWrapper.numerator());
        assertEquals(5, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee.getFixedFee().getAmount());
        assertFalse(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1009).build(), royaltyFeeWrapper.feeCollector());
        final var royaltyFeeWrapper2 = royaltyFees.get(1);
        assertEquals(4, royaltyFeeWrapper2.numerator());
        assertEquals(5, royaltyFeeWrapper2.denominator());
        final var actualFallbackFee2 = royaltyFeeWrapper2.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee2.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                actualFallbackFee2.getFixedFee().getDenominatingTokenId());
        assertNull(royaltyFeeWrapper2.feeCollector());
    }

    @Test
    void decodeTokenCreateWithEmptyAddressesAsExpected() {
        final var decodedInput =
                decodeFungibleCreateWithFees(CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS, identity());

        assertNull(decodedInput.getTreasury());
        assertNull(decodedInput.getTokenKeys().get(0).key().getContractID());
        assertNull(decodedInput.getTokenKeys().get(1).key().getDelegatableContractID());
        assertFalse(decodedInput.getFixedFees().get(0).asGrpc().hasFeeCollectorAccountId());
        assertFalse(decodedInput.getFractionalFees().get(0).asGrpc().hasFeeCollectorAccountId());
    }

    @Test
    void decodesTokenCreateWithRoyaltyFeeWithEmptyAddressesAsExpected() {
        final var decodedInput =
                decodeNonFungibleCreateWithFees(CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE, identity());

        final var royaltyFee = decodedInput.getRoyaltyFees().get(0).asGrpc();
        assertFalse(royaltyFee.hasFeeCollectorAccountId());
        assertFalse(royaltyFee.getRoyaltyFee().hasFallbackFee());
    }

    @Test
    void decodeCreateTokenWithInvalidInput() {
        final UnaryOperator<byte[]> identity = identity();
        assertThrows(
                IllegalArgumentException.class,
                () -> decodeFungibleCreate(
                        CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT, identity));
    }

    @Test
    void decodeFungibleCreateNoFeesInputV2() {
        final var decodedInput = decodeFungibleCreateV2(CREATE_FUNGIBLE_NO_FEES_INPUT_V2, identity());

        assertEquals(BigInteger.valueOf(9223372036854775807L), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(4), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        assertExpectedFungibleTokenCreateStructV2(decodedInput);
    }

    @Test
    void decodeFungibleCreateNoFeesInputV3() {
        final var decodedInput = decodeFungibleCreateV3(CREATE_FUNGIBLE_NO_FEES_INPUT_V3, identity());

        assertEquals(BigInteger.valueOf(9223372036854775807L), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(4), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        assertExpectedFungibleTokenCreateStructV2(decodedInput);
    }

    @Test
    void decodeFungibleCreateWithFeesInputV2() {
        final var decodedInput = decodeFungibleCreateWithFeesV2(CREATE_FUNGIBLE_WITH_FEES_INPUT_V2, identity());

        assertExpectedFungibleTokenCreateStructV2(decodedInput);

        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(9223372036854775807L));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(4));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder()
                        .setTokenNum(1)
                        .setRealmNum(0)
                        .setShardNum(0)
                        .build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(1, fractionalFeeWrapper.numerator());
        assertEquals(1, fractionalFeeWrapper.denominator());
        assertEquals(1, fractionalFeeWrapper.minimumAmount());
        assertEquals(1, fractionalFeeWrapper.maximumAmount());
        assertFalse(fractionalFeeWrapper.netOfTransfers());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeFungibleCreateWithFeesInputV3() {
        final var decodedInput = decodeFungibleCreateWithFeesV3(CREATE_FUNGIBLE_WITH_FEES_INPUT_V3, identity());

        assertExpectedFungibleTokenCreateStructV2(decodedInput);

        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(9223372036854775807L));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(4));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder()
                        .setTokenNum(1)
                        .setRealmNum(0)
                        .setShardNum(0)
                        .build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(1, fractionalFeeWrapper.numerator());
        assertEquals(1, fractionalFeeWrapper.denominator());
        assertEquals(1, fractionalFeeWrapper.minimumAmount());
        assertEquals(1, fractionalFeeWrapper.maximumAmount());
        assertFalse(fractionalFeeWrapper.netOfTransfers());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateNoFeesInputV2() {
        final var decodedInput = decodeNonFungibleCreateV2(CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeNonFungibleCreateNoFeesInputV3() {
        final var decodedInput = decodeNonFungibleCreateV3(CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V3, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeNonFungibleCreateWithFeesInputV2() {
        final var decodedInput = decodeNonFungibleCreateWithFeesV2(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(1, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(1, royaltyFeeWrapper.numerator());
        assertEquals(2, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(3, actualFallbackFee.getFixedFee().getAmount());
        assertTrue(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(2).build(), royaltyFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateWithFeesInputV3() {
        final var decodedInput = decodeNonFungibleCreateWithFeesV3(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V3, identity());

        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFTV2", decodedInput.getName());
        assertEquals("NFTV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemoV2", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(0L, decodedInput.getExpiry().second());
        assertEquals(8000000L, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(0, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(1).build(), customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(1, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(1, royaltyFeeWrapper.numerator());
        assertEquals(2, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(3, actualFallbackFee.getFixedFee().getAmount());
        assertTrue(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(AccountID.newBuilder().setAccountNum(2).build(), royaltyFeeWrapper.feeCollector());
    }

    @Test
    void gasAndValueRequirementCalculationWorksAsExpected() {
        // given
        givenMinFrameContext();
        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        final var transactionBody =
                TransactionBody.newBuilder().setTokenCreation(TokenCreateTransactionBody.newBuilder());

        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        given(frame.getMessageFrameStack()).willReturn(stack);
        given(stack.getLast()).willReturn(lastFrame);
        given(lastFrame.getContextVariable(PRECOMPILE_CONTEXT)).willReturn(precompileContext);
        given(precompileContext.getPrecompile()).willReturn(tokenCreatePrecompile);
        given(precompileContext.getSenderAddress()).willReturn(senderAddress);

        subject.prepareFields(frame);
        subject.prepareComputation(CREATE_NON_FUNGIBLE_NO_FEES_INPUT, a -> a, precompileContext);
        final long result =
                subject.getPrecompile(frame).getGasRequirement(TEST_CONSENSUS_TIME, transactionBody, sender);

        // then
        assertEquals(
                subject.getPrecompile(frame).getMinimumFeeInTinybars(timestamp, transactionBody.build(), sender),
                result);
    }

    @Test
    void createFungibleHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(
                new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress),
                                new byte[] {},
                                new byte[] {},
                                null)),
                new TokenKeyWrapper(
                        8,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[] {},
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreate(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_NO_FEES_INPUT);
    }

    @Test
    void createNonFungibleHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper =
                HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[JECDSASecp256k1Key.ECDSA_SECP256K1_COMPRESSED_KEY_LENGTH],
                                null))));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreate(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_NO_FEES_INPUT);
    }

    @Test
    void createFungibleWithFeesHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(frame.getMessageFrameStack()).willReturn(stack);
        given(stack.getLast()).willReturn(lastFrame);
        given(lastFrame.getContextVariable(PRECOMPILE_CONTEXT)).willReturn(precompileContext);
        given(precompileContext.getPrecompile()).willReturn(tokenCreatePrecompile);
        given(precompileContext.getSenderAddress()).willReturn(senderAddress);
        given(precompileContext.getTransactionBody()).willReturn(transactionBody);

        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                1,
                new KeyValueWrapper(
                        false,
                        null,
                        new byte[] {},
                        new byte[] {},
                        EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setFractionalFees(List.of(HTSTestsUtil.fractionalFee));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreateWithFees(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_WITH_FEES_INPUT);
    }

    @Test
    void createNonFungibleWithFeesHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper = HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(
                List.of(new TokenKeyWrapper(1, new KeyValueWrapper(false, null, ED25519_KEY, new byte[] {}, null))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setRoyaltyFees(List.of(HTSTestsUtil.royaltyFee));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateWithFees(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT);
    }

    @Test
    void createFungibleV2HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(
                new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress),
                                new byte[] {},
                                new byte[] {},
                                null)),
                new TokenKeyWrapper(
                        8,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[] {},
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreateV2(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_NO_FEES_INPUT_V2);
    }

    @Test
    void createFungibleV3HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(
                new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress),
                                new byte[] {},
                                new byte[] {},
                                null)),
                new TokenKeyWrapper(
                        8,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[] {},
                                EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreateV3(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_NO_FEES_INPUT_V3);
    }

    @Test
    void createFungibleWithFeesV2HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                1,
                new KeyValueWrapper(
                        false,
                        null,
                        new byte[] {},
                        new byte[] {},
                        EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setFractionalFees(List.of(HTSTestsUtil.fractionalFee));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreateWithFeesV2(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_WITH_FEES_INPUT_V2);
    }

    @Test
    void createFungibleWithFeesV3HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                1,
                new KeyValueWrapper(
                        false,
                        null,
                        new byte[] {},
                        new byte[] {},
                        EntityIdUtils.contractIdFromEvmAddress(HTSTestsUtil.contractAddress)))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setFractionalFees(List.of(HTSTestsUtil.fractionalFee));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreateWithFeesV3(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_FUNGIBLE_WITH_FEES_INPUT_V3);
    }

    @Test
    void createNonFungibleV2HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper =
                HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[JECDSASecp256k1Key.ECDSA_SECP256K1_COMPRESSED_KEY_LENGTH],
                                null))));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateV2(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V2);
    }

    @Test
    void createNonFungibleV3HappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper =
                HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                        1,
                        new KeyValueWrapper(
                                false,
                                null,
                                new byte[] {},
                                new byte[JECDSASecp256k1Key.ECDSA_SECP256K1_COMPRESSED_KEY_LENGTH],
                                null))));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateV3(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_NO_FEES_INPUT_V3);
    }

    @Test
    void createNonFungibleV2WithFeesHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper = HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(
                List.of(new TokenKeyWrapper(1, new KeyValueWrapper(false, null, ED25519_KEY, new byte[] {}, null))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setRoyaltyFees(List.of(HTSTestsUtil.royaltyFee));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateWithFeesV2(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V2);
    }

    @Test
    void createNonFungibleV3WithFeesHappyPathWorks() {
        // test-specific preparations
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        given(senderAccount.getId()).willReturn(new Id(0, 0, 2));
        final var tokenCreateWrapper = HTSTestsUtil.createNonFungibleTokenCreateWrapperWithKeys(
                List.of(new TokenKeyWrapper(1, new KeyValueWrapper(false, null, ED25519_KEY, new byte[] {}, null))));
        tokenCreateWrapper.setFixedFees(List.of(HTSTestsUtil.fixedFee));
        tokenCreateWrapper.setRoyaltyFees(List.of(HTSTestsUtil.royaltyFee));
        staticTokenCreatePrecompile
                .when(() -> decodeNonFungibleCreateWithFeesV3(any(), any()))
                .thenReturn(tokenCreateWrapper);
        prepareAndAssertCreateHappyPathSucceeds(CREATE_NON_FUNGIBLE_WITH_FEES_INPUT_V3);
    }

    @Test
    void createFailurePath() {
        prepareStaticContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        givenMinFrameContext();
        givenValidGasCalculation();

        givenIfDelegateCall();
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                1, new KeyValueWrapper(false, null, new byte[JEd25519Key.ED25519_BYTE_LENGTH], new byte[] {}, null))));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(CREATE_FUNGIBLE_NO_FEES_INPUT), any()))
                .thenReturn(tokenCreateWrapper);
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        // when:
        final var result = subject.computePrecompile(CREATE_FUNGIBLE_NO_FEES_INPUT, frame);

        // then:
        assertNull(result.getOutput());
        assertEquals(Optional.of(ExceptionalHaltReason.NONE), result.getHaltReason());

        verify(createLogic, never())
                .create(
                        HTSTestsUtil.pendingChildConsTime.getEpochSecond(),
                        HTSTestsUtil.senderAddress,
                        validator,
                        store,
                        transactionBody.getTokenCreation());
    }

    @Test
    void createFailsWhenCreateChecksAreNotSuccessful() {
        prepareStaticContext();
        givenMinFrameContext();
        given(worldUpdater.permissivelyUnaliased(any()))
                .willAnswer(invocationOnMock -> invocationOnMock.getArgument(0));
        givenValidGasCalculation();
        final var tokenCreateWrapper = HTSTestsUtil.createTokenCreateWrapperWithKeys(List.of(new TokenKeyWrapper(
                1, new KeyValueWrapper(false, null, new byte[JEd25519Key.ED25519_BYTE_LENGTH], new byte[] {}, null))));
        staticTokenCreatePrecompile
                .when(() -> decodeFungibleCreate(eq(CREATE_FUNGIBLE_NO_FEES_INPUT), any()))
                .thenReturn(tokenCreateWrapper);
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(store.getAccount(frame.getSenderAddress(), OnMissing.DONT_THROW)).willReturn(senderAccount);
        givenIfDelegateCall();

        // when:
        final var result = subject.computePrecompile(CREATE_FUNGIBLE_NO_FEES_INPUT, frame);

        // then:
        assertNull(result.getOutput());
        assertEquals(Optional.of(ExceptionalHaltReason.NONE), result.getHaltReason());

        verify(createLogic, never())
                .create(
                        HTSTestsUtil.pendingChildConsTime.getEpochSecond(),
                        HTSTestsUtil.senderAddress,
                        validator,
                        store,
                        transactionBody.getTokenCreation());
    }

    private void assertExpectedFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertTrue(decodedInput.isFungible());
        assertEquals("MyToken", decodedInput.getName());
        assertEquals("MTK", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("memo", decodedInput.getMemo());
        assertFalse(decodedInput.isSupplyTypeFinite());
        assertEquals(0L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(5554, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(2L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(0L, decodedInput.getExpiry().second());
    }

    private void assertExpectedKeys(final TokenCreateWrapper decodedInput) {
        final var tokenKeys = decodedInput.getTokenKeys();
        assertEquals(2, tokenKeys.size());

        final var key1 = tokenKeys.get(0);
        assertEquals(
                KeyValueWrapper.KeyValueType.INHERIT_ACCOUNT_KEY, key1.key().getKeyValueType());
        assertTrue(key1.isUsedForAdminKey());
        assertEquals(1, key1.keyType());

        final var key2 = tokenKeys.get(1);
        assertEquals(KeyValueWrapper.KeyValueType.CONTRACT_ID, key2.key().getKeyValueType());
        assertEquals(
                ContractID.newBuilder().setContractNum(1).build(), key2.key().getContractID());
        assertTrue(key2.isUsedForSupplyKey());
        assertTrue(key2.isUsedForPauseKey());
        assertEquals(80, key2.keyType());
    }

    private void assertExpectedNonFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFT", decodedInput.getName());
        assertEquals("NFT", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemo", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(55L, decodedInput.getMaxSupply());
        assertTrue(decodedInput.isFreezeDefault());
        assertEquals(67574665L, decodedInput.getExpiry().second());
        assertEquals(0L, decodedInput.getExpiry().autoRenewPeriod());
        assertNull(decodedInput.getExpiry().autoRenewAccount());
    }

    private void assertExpectedFungibleTokenCreateStructV2(final TokenCreateWrapper decodedInput) {
        assertTrue(decodedInput.isFungible());
        assertEquals("MyTokenV2", decodedInput.getName());
        assertEquals("MTKV2", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("memoV2", decodedInput.getMemo());
        assertFalse(decodedInput.isSupplyTypeFinite());
        assertEquals(9223372036854775807L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(8000000, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(4L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(0L, decodedInput.getExpiry().second());
    }

    private void givenMinFrameContext() {
        given(frame.getSenderAddress()).willReturn(senderAddress);
    }

    private void givenIfDelegateCall() {
        given(frame.getContractAddress()).willReturn(contractAddress);
        given(frame.getRecipientAddress()).willReturn(recipientAddress);
        given(worldUpdater.get(recipientAddress)).willReturn(account);
        given(account.getNonce()).willReturn(-1L);
        given(frame.getMessageFrameStack()).willReturn(stack);
        given(frame.getMessageFrameStack().iterator()).willReturn(dequeIterator);
    }

    private void prepareAndAssertCreateHappyPathSucceeds(Bytes pretendArguments) {
        givenMinFrameContext();
        given(frame.getSenderAddress()).willReturn(HTSTestsUtil.senderAddress);
        given(encoder.encodeCreateSuccess(any())).willReturn(HTSTestsUtil.successResult);
        givenValidGasCalculation();
        given(store.getAccount(senderAddress, OnMissing.THROW)).willReturn(senderAccount);
        given(senderAccount.getBalance()).willReturn(1000L);
        given(feeCalculator.computeFee(any(), any(), any()))
                .willReturn(new FeeObject(TEST_NODE_FEE, TEST_NETWORK_FEE, TEST_SERVICE_FEE));
        // when:
        given(frame.getRemainingGas()).willReturn(100_000L);
        given(frame.getValue()).willReturn(Wei.of(90_000_000_000L));
        subject.prepareFields(frame);
        subject.prepareComputation(pretendArguments, a -> a, precompileContext);
        final var result = subject.computeInternal(frame);

        // then:
        Assertions.assertEquals(HTSTestsUtil.successResult, result);
    }

    private void givenValidGasCalculation() {
        final var blockValuesMock = mock(BlockValues.class);
        given(frame.getBlockValues()).willReturn(blockValuesMock);
        given(blockValuesMock.getTimestamp()).willReturn(HTSTestsUtil.timestamp.getSeconds());
    }

    private void prepareStaticContext() {
        staticTokenCreatePrecompile = mockStatic(TokenCreatePrecompile.class);

        given(frame.getWorldUpdater()).willReturn(worldUpdater);
        given(worldUpdater.getStore()).willReturn(store);
        given(frame.getMessageFrameStack()).willReturn(stack);
        given(stack.getLast()).willReturn(lastFrame);
        given(lastFrame.getContextVariable(PRECOMPILE_CONTEXT)).willReturn(precompileContext);
        given(precompileContext.getPrecompile()).willReturn(tokenCreatePrecompile);
        given(precompileContext.getSenderAddress()).willReturn(senderAddress);
        given(precompileContext.getTransactionBody()).willReturn(transactionBody);
    }
}
